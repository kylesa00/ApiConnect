/*
 * Webshop Service API
 *
 * Webshop services connect Webshop applications to ERP system. The entry point of Webshop API is `/customers/{companyName}/{customerNr}`, which is called by Webshop application whenever a user logs in. If the customer requestedOrderPosition by its number could be found, the response contains a `_links` section, which contains all possible navigations and actions the customer can take.
 *
 * OpenAPI spec version: 2.0-draftAv
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class Documents : IEquatable<Documents>
    {
        /// <summary>
        /// The list of Documents.
        /// </summary>
        /// <value>The list of Documents.</value>
        [Required]
        [DataMember(Name= "documents")]
        public List<Document> _Documents { get; set; }

        /// <summary>
        /// Map of links, which makes URIs to other resources available through symbolic names. The following table lists possible mappings: +  +  
        /// **self (GET)**: The link to list of orders representation itself. Following this link returns the very same order list representation. +  +  
        /// **next (GET)**: The &#x60;next&#x60; link is present, if older orders than returned ones exist. This link repeats query parameters, 
        /// which are provided in original request. That way, clients do not need to construct URIs themselves to get the batch of next orders. +  + 
        /// **prev (GET)**: The &#x60;prev&#x60; link is present, if more recent orders than returned ones exit. This link repeats query parameters, which are provided in original request. That way, clients don&#39;t need to construct URIs themselves to get the batch of previous orders.
        /// </summary>
        /// <value>Map of links, which makes URIs to other resources available through symbolic names. The following table lists possible mappings: +  +  **self (GET)**: The link to list of orders representation itself. Following this link returns the very same order list representation. +  +  **next (GET)**: The &#x60;next&#x60; link is present, if older orders than returned ones exist. This link repeats query parameters, which are provided in original request. That way, clients do not need to construct URIs themselves to get the batch of next orders. +  +  **prev (GET)**: The &#x60;prev&#x60; link is present, if more recent orders than returned ones exit. This link repeats query parameters, which are provided in original request. That way, clients don&#39;t need to construct URIs themselves to get the batch of previous orders.</value>
        [Required]
        [DataMember(Name="_links")]
        public Dictionary<string, LinkEntry> Links { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Documents {\n");
            sb.Append("  _Documents: ").Append(_Documents).Append("\n");
            sb.Append("  Links: ").Append(Links).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((Documents)obj);
        }

        /// <summary>
        /// Returns true if Orders instances are equal
        /// </summary>
        /// <param name="other">Instance of Orders to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Documents other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    _Documents == other._Documents ||
                    _Documents != null &&
                    _Documents.SequenceEqual(other._Documents)
                ) && 
                (
                    Links == other.Links ||
                    Links != null &&
                    Links.SequenceEqual(other.Links)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (_Documents != null)
                    hashCode = hashCode * 59 + _Documents.GetHashCode();
                    if (Links != null)
                    hashCode = hashCode * 59 + Links.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(Documents left, Documents right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(Documents left, Documents right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
