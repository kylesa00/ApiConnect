/*
 * Webshop Service API
 *
 * Webshop services connect Webshop applications to ERP system. The entry point of Webshop API is `/customers/{companyName}/{customerNr}`, which is called by Webshop application whenever a user logs in. If the customer requestedOrderPosition by its number could be found, the response contains a `_links` section, which contains all possible navigations and actions the customer can take.
 *
 * OpenAPI spec version: 2.0-draftAv
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class InvoicePositions : IEquatable<InvoicePositions>
    { 
        /// <summary>
        /// The list of invoice positions is embedded in this resource representation.
        /// </summary>
        /// <value>The list of invoice positions is embedded in this resource representation.</value>
        [Required]
        [DataMember(Name="invoicePositions")]
        public List<InvoicePosition> _InvoicePositions { get; set; }

        /// <summary>
        /// Map of links, which makes URIs to other resources available through symbolic names. The following table lists possible links: +  +  **self (GET)**: The link to invoice positions representation itself. Following this link returns representation of the very same list of invoice positions.  +  **next (GET)**: The &#x60;next&#x60; link is present, if older invoice positions than returned ones exist. This link repeats query parameters, which are provided in original request. That way, clients do not need to construct URIs themselves to get the batch of next invoice positions. +  +  **prev (GET)**: The &#x60;prev&#x60; link is present, if more recent order postitions than returned ones exit. This link repeats query parameters, which are provided in original request. That way, clients don&#39;t need to construct URIs themselves to get the batch of previous invoice positions.           
        /// </summary>
        /// <value>Map of links, which makes URIs to other resources available through symbolic names. The following table lists possible links: +  +  **self (GET)**: The link to invoice positions representation itself. Following this link returns representation of the very same list of invoice positions.  +  **next (GET)**: The &#x60;next&#x60; link is present, if older invoice positions than returned ones exist. This link repeats query parameters, which are provided in original request. That way, clients do not need to construct URIs themselves to get the batch of next invoice positions. +  +  **prev (GET)**: The &#x60;prev&#x60; link is present, if more recent order postitions than returned ones exit. This link repeats query parameters, which are provided in original request. That way, clients don&#39;t need to construct URIs themselves to get the batch of previous invoice positions.           </value>
        [Required]
        [DataMember(Name="_links")]
        public Dictionary<string, LinkEntry> Links { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class InvoicePositions {\n");
            sb.Append("  _InvoicePositions: ").Append(_InvoicePositions).Append("\n");
            sb.Append("  Links: ").Append(Links).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((InvoicePositions)obj);
        }

        /// <summary>
        /// Returns true if InvoicePositions instances are equal
        /// </summary>
        /// <param name="other">Instance of InvoicePositions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InvoicePositions other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    _InvoicePositions == other._InvoicePositions ||
                    _InvoicePositions != null &&
                    _InvoicePositions.SequenceEqual(other._InvoicePositions)
                ) && 
                (
                    Links == other.Links ||
                    Links != null &&
                    Links.SequenceEqual(other.Links)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (_InvoicePositions != null)
                    hashCode = hashCode * 59 + _InvoicePositions.GetHashCode();
                    if (Links != null)
                    hashCode = hashCode * 59 + Links.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(InvoicePositions left, InvoicePositions right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(InvoicePositions left, InvoicePositions right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
